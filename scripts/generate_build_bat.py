#!/usr/bin/env python3
"""Generate build_internal.bat from CMakeSettings.json to match a selected configuration."""
import argparse
import json
import shutil
import pathlib
import subprocess
import sys
from typing import Dict, List, Optional


def load_settings(path: pathlib.Path) -> Dict:
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except FileNotFoundError:
        sys.exit(f"CMakeSettings.json not found: {path}")
    except json.JSONDecodeError as exc:
        sys.exit(f"Failed to parse {path}: {exc}")


def find_configuration(data: Dict, name: str) -> Dict:
    for cfg in data.get("configurations", []):
        if cfg.get("name") == name:
            return cfg
    available = [cfg.get("name", "<unnamed>") for cfg in data.get("configurations", [])]
    sys.exit(f"Configuration '{name}' not found. Available: {', '.join(available)}")


def render_value(raw: str, project_var: str, cfg_name: str, normalize_path: bool = False, project_var_path: str = None) -> str:
    # Translate CMakeSettings placeholders into batch-friendly forms.
    substitute_project = project_var_path if (normalize_path and project_var_path) else project_var
    value = raw.replace("${projectDir}", substitute_project)
    value = value.replace("${name}", cfg_name)
    # ${env.VAR} -> %VAR%
    idx = 0
    while "${env." in value[idx:]:
        start = value.find("${env.", idx)
        end = value.find("}", start)
        if start == -1 or end == -1:
            break
        env_key = value[start + len("${env."): end]
        value = value[:start] + f"%{env_key}%" + value[end + 1:]
        idx = start + len(env_key) + 2
    if normalize_path:
        # Normalize to forward slashes to avoid CMake escape issues.
        value = value.replace("/", "/")
    return value


def to_cmake_path(val: str) -> str:
    """Convert Windows path to CMake-friendly form (forward slashes)."""
    return val.replace("/", "/")


def is_multi_config(generator: str) -> bool:
    gen = generator.lower()
    return "visual studio" in gen or "xcode" in gen or "multi-config" in gen


def build_configure_lines(cfg: Dict, project_var: str) -> List[str]:
    # Force Visual Studio generator to avoid missing Ninja on user machines.
    generator = "Visual Studio 17 2022"
    generator_args = "-A x64 -T v143"
    cfg_type = cfg.get("configurationType", "Release")
    variables = cfg.get("variables", [])

    # Automatically mirror DXRT_DIR into DXRT_INSTALLED_DIR if not explicitly set.
    variables_with_derived = list(variables)
    has_dxrt_installed = any(v.get("name") == "DXRT_INSTALLED_DIR" for v in variables)
    for var in variables:
        if var.get("name") == "DXRT_DIR" and not has_dxrt_installed:
            derived = dict(var)
            derived["name"] = "DXRT_INSTALLED_DIR"
            # Treat as PATH to normalize separators for CMake.
            derived["type"] = derived.get("type", "PATH")
            variables_with_derived.append(derived)
            break

    build_root_raw = cfg.get("buildRoot", f"{project_var}/build/{cfg_type}")
    install_root_raw = cfg.get("installRoot", f"{project_var}/install/{cfg_type}")
    build_root = render_value(build_root_raw, project_var, cfg.get("name", cfg_type))
    install_root = render_value(install_root_raw, project_var, cfg.get("name", cfg_type))

    lines: List[str] = []
    lines.append("@echo off")
    lines.append("setlocal")
    lines.append("REM Auto-generated by scripts/generate_build_bat.py")
    lines.append("set \"PROJECT_DIR=%~dp0\"")
    lines.append("set \"PROJECT_DIR=%PROJECT_DIR:~0,-1%\"")
    lines.append(f"set \"BUILD_DIR={build_root}\"")
    lines.append(f"set \"INSTALL_DIR={install_root}\"")
    lines.append("set \"PROJECT_DIR_FWD=%PROJECT_DIR:\=/%\"")
    lines.append(f"set \"GENERATOR={generator}\"")
    lines.append(f"set \"GENERATOR_ARGS={generator_args}\"")

    lines.append("")
    lines.append("REM Clean stale CMake cache to avoid generator mismatch")
    lines.append("if exist \"%BUILD_DIR%/CMakeCache.txt\" (")
    lines.append("  del /f /q \"%BUILD_DIR%/CMakeCache.txt\"")
    lines.append(")")
    lines.append("if exist \"%BUILD_DIR%/CMakeFiles\" (")
    lines.append("  rmdir /s /q \"%BUILD_DIR%/CMakeFiles\"")
    lines.append(")")

    for var in variables_with_derived:
        name = var.get("name")
        raw_val = var.get("value", "")
        normalize = var.get("type", "").upper() == "PATH"
        if not name:
            continue
        value = render_value(
            raw_val,
            "%PROJECT_DIR%",
            cfg.get("name", cfg_type),
            normalize_path=normalize,
            project_var_path="%PROJECT_DIR_FWD%",
        )
        lines.append(f"set \"{name}={value}\"")

    lines.append("")
    lines.append(f"echo Configuring with generator: {generator} (%GENERATOR_ARGS%)")

    cfg_lines: List[str] = []
    cfg_lines.append("cmake -S \"%PROJECT_DIR%\" -B \"%BUILD_DIR%\" ^")
    cfg_lines.append("  -G \"%GENERATOR%\" ^")
    if generator_args:
        cfg_lines.append("  %GENERATOR_ARGS% ^")
    if not is_multi_config(generator):
        cfg_lines.append(f"  -DCMAKE_BUILD_TYPE={cfg_type} ^")
    for var in variables_with_derived:
        name = var.get("name")
        raw_val = var.get("value", "")
        normalize = var.get("type", "").upper() == "PATH"
        if not name:
            continue
        rendered = render_value(
            raw_val,
            "%PROJECT_DIR%",
            cfg.get("name", cfg_type),
            normalize_path=normalize,
            project_var_path="%PROJECT_DIR_FWD%",
        )
        cmake_value = to_cmake_path(rendered) if normalize else rendered
        cfg_lines.append(f"  -D{name}=\"{cmake_value}\" ^")
    cfg_lines[-1] = cfg_lines[-1].rstrip(" ^")

    lines.extend(cfg_lines)
    lines.append("IF %ERRORLEVEL% NEQ 0 goto :err")
    lines.append("")
    lines.append(f"cmake --build \"%BUILD_DIR%\" --config {cfg_type}")
    lines.append("IF %ERRORLEVEL% NEQ 0 goto :err")
    lines.append("")
    lines.append(f"cmake --install \"%BUILD_DIR%\" --config {cfg_type} --prefix \"%INSTALL_DIR%\"")
    lines.append("IF %ERRORLEVEL% NEQ 0 goto :err")
    lines.append("")
    lines.append("echo Build and install completed successfully.")
    lines.append("pause")
    lines.append("goto :eof")
    lines.append("")
    lines.append(":err")
    lines.append("echo Failed with exit code %ERRORLEVEL%.")
    lines.append("pause")
    lines.append("exit /b %ERRORLEVEL%")

    return lines


def write_bat(lines: List[str], dest: pathlib.Path) -> None:
    dest.write_text("\n".join(lines) + "\n", encoding="utf-8")


def write_env_bat(dxrt_dir: Optional[str], dest: pathlib.Path) -> None:
    lines: List[str] = ["@echo off"]
    lines.append("if not defined PROJECT_ROOT for %%A in (\"%~dp0.\") do set \"PROJECT_ROOT=%%~fA\\\"")
    lines.append("set \"VENV_SCRIPTS=%PROJECT_ROOT%venv\\Scripts\"")
    lines.append("set \"VENV_SITE=%PROJECT_ROOT%venv\\Lib\\site-packages\"")

    dxrt_dir = to_cmake_path(dxrt_dir)
    if dxrt_dir:
        lines.append(f"set \"DXRT_DIR={dxrt_dir}\"")
        lines.append(f"set \"DXRT_INSTALLED_DIR={dxrt_dir}\"")
        lines.append("set \"CMAKE_PREFIX_PATH=%DXRT_DIR%;%CMAKE_PREFIX_PATH%\"")
        lines.append("set \"DXRT_DLL_DIR=%DXRT_INSTALLED_DIR%/bin\"")
        lines.append("set \"DXRT_LIB_DIR=%DXRT_INSTALLED_DIR%/lib\"")
        lines.append("set \"DXRT_INCLUDE_DIR=%DXRT_INSTALLED_DIR%/include\"")
    else:
        lines.append("REM DXRT_DIR not defined in CMakeSettings; nothing to export")

    lines.append("")
    lines.append("REM Prefer venv Python and ensure DXRT DLLs are on PATH")
    lines.append("if exist \"%VENV_SCRIPTS%\" set \"PATH=%VENV_SCRIPTS%;%PATH%\"")
    lines.append("if exist \"%DXRT_INSTALLED_DIR%\\bin\\dxrt.dll\" if exist \"%VENV_SITE%\" copy /Y \"%DXRT_INSTALLED_DIR%\\bin\\dxrt.dll\" \"%VENV_SITE%\" >nul")

    lines.append("echo DXRT build environment configured.")
    write_bat(lines, dest)


def run_bat(path: pathlib.Path) -> int:
    # Runs the generated batch in-place so CMake sees the same cwd.
    try:
        completed = subprocess.run(
            f'"{path}"', shell=True, check=False
        )
        return completed.returncode
    except FileNotFoundError:
        sys.exit(f"Cannot run missing file: {path}")


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate build_internal.bat from CMakeSettings.json")
    parser.add_argument("--config", default="x64-Release", help="Configuration name from CMakeSettings.json")
    parser.add_argument("--cmake-settings", default="CMakeSettings.json", help="Path to CMakeSettings.json")
    parser.add_argument("--output", default="build_internal.bat", help="Output batch file path")
    parser.add_argument("--run", action="store_true", help="Run the generated build_internal.bat after creating it")
    args = parser.parse_args()

    settings_path = pathlib.Path(args.cmake_settings)
    data = load_settings(settings_path)
    cfg = find_configuration(data, args.config)
    project_root = pathlib.Path(__file__).resolve().parent.parent
    cfg_type = cfg.get("configurationType", "Release")
    build_root_raw = cfg.get("buildRoot", f"%PROJECT_DIR%/build/{cfg_type}")

    # Render DXRT_DIR if present so we can export it for downstream steps (e.g., pybind build).
    dxrt_dir_val: Optional[str] = None
    for var in cfg.get("variables", []):
        if var.get("name") == "DXRT_DIR":
            raw_val = var.get("value", "")
            normalize = var.get("type", "").upper() == "PATH"
            dxrt_dir_val = render_value(
                raw_val,
                "%PROJECT_DIR%",
                cfg.get("name", cfg.get("configurationType", "")),
                normalize_path=normalize,
                project_var_path="%PROJECT_DIR_FWD%",
            )
            break

    lines = build_configure_lines(cfg, "%PROJECT_DIR%")
    out_path = pathlib.Path(args.output)
    out_path.parent.mkdir(parents=True, exist_ok=True)
    write_bat(lines, out_path)
    print(f"Wrote {out_path}")

    env_out = out_path.with_name("build_env.bat")
    write_env_bat(dxrt_dir_val, env_out)
    print(f"Wrote {env_out}")

    if args.run:
        # Clean the build directory to avoid generator or toolset conflicts.
        cleanup_build = render_value(
            build_root_raw,
            str(project_root),
            cfg.get("name", cfg_type),
            normalize_path=True,
            project_var_path=str(project_root).replace("\\", "/"),
        )
        cleanup_path = pathlib.Path(cleanup_build)
        if cleanup_path.exists():
            shutil.rmtree(cleanup_path, ignore_errors=True)
            print(f"Removed existing build directory: {cleanup_path}")
        print(f"Running {out_path}...")
        rc = run_bat(out_path)
        if rc != 0:
            sys.exit(rc)
        print("build_internal.bat finished successfully.")


if __name__ == "__main__":
    main()
